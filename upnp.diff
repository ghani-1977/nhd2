diff -Naur 2379/configure.ac 2380/configure.ac
--- 2379/configure.ac	2014-12-31 15:52:26.000000000 +0100
+++ 2380/configure.ac	2014-12-31 15:53:31.000000000 +0100
@@ -162,6 +162,7 @@
 lib/timerdclient/Makefile
 lib/libtuxtxt/Makefile
 lib/libdvbsub/Makefile
+lib/libupnpclient/Makefile
 lib/liblcddisplay/Makefile
 lib/libdvbapi/Makefile
 lib/libeplayer3/Makefile
diff -Naur 2379/lib/libupnpclient/Makefile.am 2380/lib/libupnpclient/Makefile.am
--- 2379/lib/libupnpclient/Makefile.am	1970-01-01 01:00:00.000000000 +0100
+++ 2380/lib/libupnpclient/Makefile.am	2014-12-31 15:53:26.000000000 +0100
@@ -0,0 +1,6 @@
+noinst_LIBRARIES = libtuxbox-upnpclient.a
+
+INCLUDES = \
+	-I$(top_srcdir)/lib/libxmltree
+
+libtuxbox_upnpclient_a_SOURCES = UPNPSocket.cpp UPNPDevice.cpp UPNPService.cpp
diff -Naur 2379/lib/libupnpclient/upnpclient.h 2380/lib/libupnpclient/upnpclient.h
--- 2379/lib/libupnpclient/upnpclient.h	1970-01-01 01:00:00.000000000 +0100
+++ 2380/lib/libupnpclient/upnpclient.h	2014-12-31 15:53:26.000000000 +0100
@@ -0,0 +1,116 @@
+/***********************************************************************************
+ *   upnpclient.h
+ *
+ *   Copyright (c) 2007 Jochen Friedrich
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
+ *
+ ***********************************************************************************/
+
+#ifndef __UPNP_H
+#define __UPNP_H
+
+#include <utility>
+#include <list>
+#include <vector>
+#include <string>
+
+#define MULTICAST_PORT 1900
+#define MULTICAST_IP   "239.255.255.250"
+
+typedef std::pair<std::string, std::string> UPnPAttribute;
+
+struct UPnPIcon
+{
+	std::string mimetype;
+	std::string url;
+	int         width;
+	int         heigth;
+	int         depth;
+};
+
+class CUPnPService;
+
+/******************************************
+ * Class: CUPnPDevice
+ ******************************************/
+
+class CUPnPDevice
+{
+	friend class CUPnPService;
+	friend class CUPnPSocket;
+
+	private:
+		std::string  descurl;
+		std::list<CUPnPService> services;
+		std::string HTTP(std::string url,std::string post="", std::string action="");
+		bool check_response(std::string header, std::string& charset, std::string& rcode);
+		std::list<UPnPIcon> icons;
+
+	public:
+		std::string friendlyname;
+		std::string devicetype;
+		std::string manufacturer;
+		std::string manufacturerurl;
+		std::string modeldescription;
+		std::string modelname;
+		std::string modelnumber;
+		std::string modelurl;
+		std::string serialnumber;
+		std::string udn;
+		std::string upc;
+		std::list<UPnPAttribute> SendSOAP(std::string service, std::string action, std::list<UPnPAttribute> attribs);
+		std::list<std::string> GetServices(void);
+		std::list<UPnPIcon> GetIcons() const { return icons; };
+
+		CUPnPDevice(std::string url);
+		~CUPnPDevice();
+};
+
+/******************************************
+ * Class: CUPnPService
+ ******************************************/
+class CUPnPService
+{
+
+	public:
+		std::string  controlurl;
+		std::string  eventurl;
+		std::string  servicename;
+		CUPnPDevice *device;
+
+		CUPnPService(CUPnPDevice *dev, std::string curl, std::string eurl, std::string service);
+		~CUPnPService();
+		std::list<UPnPAttribute> SendSOAP(std::string action, std::list<UPnPAttribute> attribs);
+};
+
+/******************************************
+ * Class: CUPnPSocket
+ ******************************************/
+class CUPnPSocket
+{
+	public:
+		CUPnPSocket();
+		~CUPnPSocket();
+
+		void SetTTL(int ttl);
+		std::vector<CUPnPDevice> Discover(std::string service);
+
+	private:
+		int m_socket;
+
+};
+
+#endif
diff -Naur 2379/lib/libupnpclient/UPNPDevice.cpp 2380/lib/libupnpclient/UPNPDevice.cpp
--- 2379/lib/libupnpclient/UPNPDevice.cpp	1970-01-01 01:00:00.000000000 +0100
+++ 2380/lib/libupnpclient/UPNPDevice.cpp	2014-12-31 15:53:26.000000000 +0100
@@ -0,0 +1,471 @@
+/***********************************************************************************
+ *   UPNPDevice.cpp
+ *
+ *   Copyright (c) 2007 Jochen Friedrich
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
+ *
+ ***********************************************************************************/
+
+#include <iostream>
+#include <sstream>
+#include <stdexcept>
+#include <string.h>
+#include <xmltree.h>
+#include <sys/types.h>
+#include <sys/socket.h>
+#include <netinet/in.h>
+#include <arpa/inet.h>
+#include <netdb.h>
+#include <stdlib.h>
+#include <poll.h>
+#include <unistd.h>
+#include <algorithm>
+
+#include "upnpclient.h"
+
+
+struct ToLower
+{
+	char operator() (char c) const { return std::tolower(c); }
+};
+
+static void trim(std::string &buf)
+{
+	std::string::size_type pos1, pos2;
+
+	pos1 = buf.find_first_not_of(" \t\n\r");
+	pos2 = buf.find_last_not_of(" \t\n\r");
+	if ((pos1 == std::string::npos) || (pos2 == std::string::npos))
+		buf="";
+	else
+		buf = buf.substr(pos1, pos2 - pos1 + 1);
+}
+
+bool CUPnPDevice::check_response(std::string header, std::string& charset, std::string& rcode)
+{
+	std::string::size_type pos;
+	std::string content, attrib, chars;
+
+	charset="ISO-8859-1";
+
+	pos = header.find("\r");
+	if (pos == std::string::npos)
+		return false;
+
+	rcode = header.substr(0, pos);
+	if (rcode.substr(0,5) != "HTTP/")
+		return false;
+
+	pos = rcode.find(" ");
+	if (pos == std::string::npos)
+		return false;
+
+	rcode.erase(0, pos);
+	trim(rcode);
+
+	pos = rcode.find(" ");
+	if (pos != std::string::npos)
+	{
+		rcode.erase(pos);
+		trim(rcode);
+	}
+
+	std::transform(header.begin(), header.end(), header.begin(), ToLower());
+
+	pos = header.find("content-type:");
+	if (pos == std::string::npos)
+		return false;
+
+	content = header.substr(pos);
+	content.erase(0,13);
+	pos = content.find("\n");
+	if (pos != std::string::npos)
+		content.erase(pos);
+
+	trim(content);
+
+	pos=content.find(";");
+	if (pos!=std::string::npos)
+	{
+		attrib=content.substr(pos+1);
+		content.erase(pos);
+		trim(content);
+	}
+	if (content != "text/xml")
+		return false;
+
+	trim(attrib);
+	if (attrib.substr(0,8) == "charset=")
+	{
+		attrib.erase(0,8);
+		pos = attrib.find("\"");
+		if (pos!=std::string::npos)
+		{
+			attrib.erase(0,pos+1);
+			pos = attrib.find("\"");
+			if (pos==std::string::npos)
+				return false;
+			chars=attrib.substr(0,pos);
+		}
+		else
+			chars=attrib;
+		if (!strcasecmp(chars.c_str(), "utf-8"))
+			charset = "UTF-8";
+	}
+	return true;
+}
+
+CUPnPDevice::CUPnPDevice(std::string url)
+{
+	std::string result, head, body, charset, urlbase;
+	std::string curl, eurl, name, mimetype, iurl, rcode;
+	std::string::size_type pos;
+	XMLTreeNode *root, *device, *service, *node, *snode, *icon;
+	int width = 0;
+	int height = 0;
+	int depth = 0;
+	bool servicefound = false;
+
+	descurl = url;
+	urlbase = url.substr(7);
+	pos = urlbase.find("/");
+	if (pos != std::string::npos)
+		urlbase=url.substr(0,pos+7);
+	else
+		urlbase=url;
+
+	result = HTTP(url);
+
+	pos = result.find("\r\n\r\n");
+
+	if (pos == std::string::npos)
+		throw std::runtime_error(std::string("no desc body"));
+
+	head = result.substr(0,pos);
+	body = result.substr(pos+4);
+
+	if (body == "")
+		throw std::runtime_error(std::string("desc body empty"));
+
+	if (!check_response(head, charset, rcode))
+		throw std::runtime_error(std::string("protocol error"));
+
+	if (rcode != "200")
+		throw std::runtime_error(std::string("description url returned ") + rcode);
+	XMLTreeParser parser(charset.c_str());
+	parser.Parse(body.c_str(), body.size(), 1);
+	root = parser.RootNode();
+	if (!root)
+		throw std::runtime_error(std::string("XML: no root node"));
+
+	if (strcmp(root->GetType(),"root"))
+		throw std::runtime_error(std::string("XML: no root"));
+
+	for (node = root->GetChild(); node; node=node->GetNext())
+	{
+		if (!strcmp(node->GetType(),"URLBase"))
+		{
+			urlbase = std::string(node->GetData());
+			if ((urlbase.length() > 0) && (urlbase[urlbase.length()-1] == '/'))
+				urlbase.erase(urlbase.length()-1);
+		}
+
+	}
+
+	node = root->GetChild();
+	if (!node)
+		throw std::runtime_error(std::string("XML: no root child"));
+
+	while (strcmp(node->GetType(),"device"))
+	{
+		node = node->GetNext();
+		if (!node)
+			throw std::runtime_error(std::string("XML: no device"));
+	}
+	device = node;
+
+	for (node=device->GetChild(); node; node=node->GetNext())
+	{
+		if (!strcmp(node->GetType(),"deviceType"))
+			devicetype = std::string(node->GetData()?node->GetData():"");
+
+		if (!strcmp(node->GetType(),"friendlyName"))
+			friendlyname = std::string(node->GetData()?node->GetData():"");
+
+		if (!strcmp(node->GetType(),"manufacturer"))
+			manufacturer = std::string(node->GetData()?node->GetData():"");
+
+		if (!strcmp(node->GetType(),"manufacturerURL"))
+			manufacturerurl = std::string(node->GetData()?node->GetData():"");
+
+		if (!strcmp(node->GetType(),"modelDescription"))
+			modeldescription = std::string(node->GetData()?node->GetData():"");
+
+		if (!strcmp(node->GetType(),"modelName"))
+			modelname = std::string(node->GetData()?node->GetData():"");
+
+		if (!strcmp(node->GetType(),"modelNumber"))
+			modelnumber = std::string(node->GetData()?node->GetData():"");
+
+		if (!strcmp(node->GetType(),"modelURL"))
+			modelurl = std::string(node->GetData()?node->GetData():"");
+
+		if (!strcmp(node->GetType(),"serialNumber"))
+			serialnumber = std::string(node->GetData()?node->GetData():"");
+
+		if (!strcmp(node->GetType(),"UDN"))
+			udn = std::string(node->GetData()?node->GetData():"");
+
+		if (!strcmp(node->GetType(),"UPC"))
+			upc = std::string(node->GetData()?node->GetData():"");
+
+		if (!strcmp(node->GetType(),"iconList"))
+		{
+			for (icon=node->GetChild(); icon; icon=icon->GetNext())
+			{
+				bool foundm = false;
+				bool foundw = false;
+				bool foundh = false;
+				bool foundd = false;
+				bool foundu = false;
+
+				if (strcmp(icon->GetType(),"icon"))
+					throw std::runtime_error(std::string("XML: no icon"));
+				for (snode=icon->GetChild(); snode; snode=snode->GetNext())
+				{
+					if (!strcmp(snode->GetType(),"mimetype"))
+					{
+						mimetype=std::string(snode->GetData()?snode->GetData():"");
+						foundm = true;
+					}
+					if (!strcmp(snode->GetType(),"width"))
+					{
+						width=snode->GetData()?atoi(snode->GetData()):0;
+						foundw = true;
+					}
+					if (!strcmp(snode->GetType(),"height"))
+					{
+						height=snode->GetData()?atoi(snode->GetData()):0;
+						foundh = true;
+					}
+					if (!strcmp(snode->GetType(),"depth"))
+					{
+						depth=snode->GetData()?atoi(snode->GetData()):0;
+						foundd = true;
+					}
+					if (!strcmp(snode->GetType(),"url"))
+					{
+						url=std::string(snode->GetData()?snode->GetData():"");
+						foundu = true;
+					}
+				}
+				if (!foundm)
+					throw std::runtime_error(std::string("XML: icon without mime"));
+				if (!foundw)
+					throw std::runtime_error(std::string("XML: icon without width"));
+				if (!foundh)
+					throw std::runtime_error(std::string("XML: icon without height"));
+				if (!foundd)
+					throw std::runtime_error(std::string("XML: icon without depth"));
+				if (!foundu)
+					throw std::runtime_error(std::string("XML: icon without url"));
+				UPnPIcon e={mimetype, url, width, height, depth};
+				icons.push_back(e);
+			}
+		}
+		if (!strcmp(node->GetType(),"serviceList"))
+		{
+			servicefound = true;
+			for (service=node->GetChild(); service; service=service->GetNext())
+			{
+				bool foundc = false;
+				bool founde = false;
+				bool foundn = false;
+
+				if (strcmp(service->GetType(),"service"))
+					throw std::runtime_error(std::string("XML: no service"));
+				for (snode=service->GetChild(); snode; snode=snode->GetNext())
+				{
+					if (!strcmp(snode->GetType(),"serviceType"))
+					{
+						name=std::string(snode->GetData()?snode->GetData():"");
+						foundn = true;
+					}
+					if (!strcmp(snode->GetType(),"eventSubURL"))
+					{
+						char *p;
+						p = snode->GetData();
+						if (!p)
+							eurl=urlbase + "/";
+						else if (p[0]=='/')
+							eurl=urlbase + std::string(p);
+						else
+							eurl=urlbase + "/" + std::string(p);
+						founde = true;
+					}
+					if (!strcmp(snode->GetType(),"controlURL"))
+					{
+						char *p;
+						p = snode->GetData();
+						if (!p)
+							curl=urlbase + "/";
+						else if (p[0]=='/')
+							curl=urlbase + std::string(p);
+						else
+							curl=urlbase + "/" + std::string(p);
+						foundc = true;
+					}
+				}
+				if (!foundn)
+					throw std::runtime_error(std::string("XML: no service type"));
+				if (!founde)
+					throw std::runtime_error(std::string("XML: no event url"));
+				if (!foundc)
+					throw std::runtime_error(std::string("XML: no control url"));
+				//try
+				{
+					services.push_back(CUPnPService(this, curl, eurl, name));
+				}
+				//catch (std::runtime_error error)
+				//{
+				//	std::cout << "error " << error.what() << "\n";
+				//}
+			}
+		}
+	}
+	if (!servicefound)
+		throw std::runtime_error(std::string("XML: no service list"));
+}
+
+CUPnPDevice::~CUPnPDevice()
+{
+}
+
+std::string CUPnPDevice::HTTP(std::string url, std::string post, std::string action)
+{
+	std::string portname;
+	std::string hostname;
+	std::string path;
+	int port, t_socket, received;
+	std::stringstream command, reply;
+	std::string commandstr, line;
+	struct sockaddr_in socktcp;
+	struct hostent *hp;
+	std::string::size_type pos1, pos2;
+	char buf[4096];
+
+	if (url.substr(0,7) != "http://")
+		return "";
+
+	url.erase(0,7);
+
+	pos1 = url.find(":", 0);
+	pos2 = url.find("/", 0);
+
+	if (pos2 == std::string::npos)
+		return "";
+	if ((pos1 == std::string::npos) || (pos1 > pos2))
+	{
+		hostname = url.substr(0,pos2);
+		port=80;
+	}
+	else
+	{
+		hostname = url.substr(0,pos1);
+		portname = url.substr(pos1+1, pos2-pos1-1);
+		port = atoi(portname.c_str());
+	}
+	path = url.substr(pos2);
+
+	if (post.size())
+		command << "POST " << path << " HTTP/1.0\r\n";
+	else
+		command << "GET " << path << " HTTP/1.0\r\n";
+
+	command << "Host: " << hostname << ":" << port << "\r\n";
+	command << "User-Agent: TuxBox\r\n";
+	command << "Accept: text/xml\r\n";
+	command << "Connection: Close\r\n";
+
+	if (post.size())
+	{
+		command << "Content-Length: " << post.size() << "\r\n";
+		command << "Content-Type: text/xml\r\n";
+	}
+
+	if (action.size())
+		command << "SOAPAction: \"" << action << "\"\r\n";
+
+	command << "\r\n";
+
+	if (post.size())
+		command << post;
+
+	t_socket = socket(PF_INET, SOCK_STREAM, 0);
+	if (!t_socket)
+		throw std::runtime_error(std::string("create TCP socket"));
+
+	hp = gethostbyname(hostname.c_str());
+	if (!hp)
+		throw std::runtime_error(std::string("resolve name"));
+
+	memset(&socktcp, 0, sizeof(struct sockaddr_in));
+	socktcp.sin_family = AF_INET;
+	socktcp.sin_port = htons(port);
+	memmove((char *)&socktcp.sin_addr, hp->h_addr, hp->h_length);
+
+	if (connect(t_socket, (struct sockaddr*) &socktcp, sizeof(struct sockaddr_in)))
+	{
+		close(t_socket);
+		throw std::runtime_error(std::string("connect"));
+	}
+
+	commandstr = command.str();
+	send(t_socket, commandstr.c_str(), commandstr.size(), 0);
+	while ((received = recv(t_socket, buf, sizeof(buf)-1, 0)) > 0)
+	{
+		buf[received] = 0;
+		reply << buf;
+	}
+	
+	close(t_socket);
+	
+	return reply.str();
+}
+
+std::list<UPnPAttribute> CUPnPDevice::SendSOAP(std::string servicename, std::string action, std::list<UPnPAttribute> attribs)
+{
+	std::list<CUPnPService>::iterator i;
+	std::list<UPnPAttribute> empty;
+
+	for (i=services.begin(); i != services.end(); ++i)
+	{
+		if (i->servicename == servicename)
+			return i->SendSOAP(action, attribs);
+	}
+	return empty;
+}
+
+std::list<std::string> CUPnPDevice::GetServices(void)
+{
+	std::list<CUPnPService>::iterator i;
+	std::list<std::string> result;
+
+	for (i=services.begin(); i != services.end(); ++i)
+		result.push_back(i->servicename);
+	return result;
+}
+
diff -Naur 2379/lib/libupnpclient/UPNPService.cpp 2380/lib/libupnpclient/UPNPService.cpp
--- 2379/lib/libupnpclient/UPNPService.cpp	1970-01-01 01:00:00.000000000 +0100
+++ 2380/lib/libupnpclient/UPNPService.cpp	2014-12-31 15:53:26.000000000 +0100
@@ -0,0 +1,172 @@
+/***********************************************************************************
+ *   UPNPService.cpp
+ *
+ *   Copyright (c) 2007 Jochen Friedrich
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
+ *
+ ***********************************************************************************/
+
+#include <iostream>
+#include <sstream>
+#include <stdexcept>
+#include <string.h>
+#include <xmltree.h>
+#include <sys/types.h>
+#include <sys/socket.h>
+#include <netinet/in.h>
+#include <arpa/inet.h>
+#include <netdb.h>
+#include <stdlib.h>
+#include <poll.h>
+#include "upnpclient.h"
+
+CUPnPService::CUPnPService(CUPnPDevice* dev, std::string curl, std::string eurl, std::string name)
+{
+	device = dev;
+	controlurl = curl;
+	eventurl = eurl;
+	servicename = name;
+}
+
+CUPnPService::~CUPnPService()
+{
+}
+
+std::list<UPnPAttribute> CUPnPService::SendSOAP(std::string action, std::list<UPnPAttribute> attribs)
+{
+	std::stringstream post;
+	std::string soapaction;
+	std::string result, head, body, charset, envelope, soapbody, soapresponse, rcode;
+	std::list<UPnPAttribute>::iterator i;
+	std::list<UPnPAttribute> results;
+	XMLTreeNode *root, *node, *snode;
+	std::string::size_type pos;
+
+	post << "<?xml version=\"1.0\"?>\r\n"
+	        "<SOAP-ENV:Envelope "
+		"xmlns:SOAP-ENV=\"http://schemas.xmlsoap.org/soap/envelope/\" "
+		"SOAP-ENV:encodingStyle=\"http://schemas.xmlsoap.org/soap/encoding/\">"
+		"<SOAP-ENV:Body>";
+		post << "<m:" << action << " xmlns:m=\"" << servicename << "\"";
+
+	if (attribs.empty())
+	{
+		post << "/>";
+	} else {
+		post << ">";
+		for (i = attribs.begin(); i != attribs.end(); ++i)
+		{
+			if (i->second == "")
+				post << "<" << i->first << "/>";
+			else
+			{
+				post << "<" << i->first << ">";
+				post << i->second;
+				post << "</" << i->first << ">";
+			}
+		}
+		post << "</m:" << action << ">";
+	}
+	post << "</SOAP-ENV:Body></SOAP-ENV:Envelope>\r\n";
+	soapaction = servicename + "#" + action;
+	result = device->HTTP(controlurl, post.str(), soapaction);
+
+	pos = result.find("\r\n\r\n");
+
+	if (pos == std::string::npos)
+		throw std::runtime_error(std::string("no soap body"));
+
+	head = result.substr(0,pos);
+	body = result.substr(pos+4);
+
+	if (!device->check_response(head, charset, rcode))
+		throw std::runtime_error(std::string("protocol error"));
+
+	XMLTreeParser parser(charset.c_str());
+	parser.Parse(body.c_str(), body.size(), 1);
+	root = parser.RootNode();
+	if (!root)
+		throw std::runtime_error(std::string("XML: no root node"));
+
+	envelope=std::string(root->GetType());
+	pos = envelope.find(":");
+	if (pos !=std::string::npos)
+		envelope.erase(0,pos+1);
+
+	if (envelope != "Envelope")
+		throw std::runtime_error(std::string("XML: no envelope"));
+
+	node = root->GetChild();
+	if (!node)
+		throw std::runtime_error(std::string("XML: no envelope child"));
+
+	soapbody=std::string(node->GetType());
+	pos = soapbody.find(":");
+	if (pos !=std::string::npos)
+		soapbody.erase(0,pos+1);
+
+	if (soapbody != "Body")
+		throw std::runtime_error(std::string("XML: no soap body"));
+
+	node = node->GetChild();
+	if (!node)
+		throw std::runtime_error(std::string("XML: no soap body child"));
+
+	soapresponse=std::string(node->GetType());
+	pos = soapresponse.find(":");
+	if (pos !=std::string::npos)
+		soapresponse.erase(0,pos+1);
+
+	if (rcode != "200")
+	{
+		std::string faultstring, upnpcode, upnpdesc, errstr;
+		if (soapresponse != "Fault")
+			throw std::runtime_error(std::string("XML: http error without soap fault: ")+rcode);
+		for (node=node->GetChild(); node; node=node->GetNext())
+		{
+			if (!strcmp(node->GetType(),"detail"))
+			{
+				snode=node->GetChild();
+				if (snode)
+					for (snode=snode->GetChild(); snode; snode=snode->GetNext())
+					{
+						errstr=snode->GetType();
+						pos = errstr.find(":");
+						if (pos !=std::string::npos)
+							errstr.erase(0,pos+1);
+						if (errstr=="errorCode")
+							upnpcode=std::string(snode->GetData()?snode->GetData():"");
+						if (errstr=="errorDescription")
+							upnpdesc=std::string(snode->GetData()?snode->GetData():"");
+					}
+
+			}
+			if (!strcmp(node->GetType(),"faultstring"))
+				faultstring=std::string(node->GetData()?node->GetData():"");
+		}
+		if (faultstring != "")
+			throw std::runtime_error(faultstring + " " + upnpcode + " " + upnpdesc);
+		else
+			throw std::runtime_error(std::string("XML: http error with unknown soap: ")+rcode);
+	}
+	if (soapresponse != action + "Response")
+		throw std::runtime_error(std::string("XML: no soap response"));
+
+	for (node=node->GetChild(); node; node=node->GetNext())
+		results.push_back(UPnPAttribute(node->GetType(), node->GetData()));
+
+	return results;
+}
diff -Naur 2379/lib/libupnpclient/UPNPSocket.cpp 2380/lib/libupnpclient/UPNPSocket.cpp
--- 2379/lib/libupnpclient/UPNPSocket.cpp	1970-01-01 01:00:00.000000000 +0100
+++ 2380/lib/libupnpclient/UPNPSocket.cpp	2014-12-31 15:53:26.000000000 +0100
@@ -0,0 +1,161 @@
+/***********************************************************************************
+ *   UPNPSocket.cpp
+ *
+ *   Copyright (c) 2007 Jochen Friedrich
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
+ *
+ ***********************************************************************************/
+
+#include <iostream>
+#include <sstream>
+#include <stdexcept>
+#include <string.h>
+#include <xmltree.h>
+#include <sys/types.h>
+#include <sys/socket.h>
+#include <netinet/in.h>
+#include <arpa/inet.h>
+#include <netdb.h>
+#include <stdlib.h>
+#include <poll.h>
+#include <errno.h>
+#include <unistd.h>
+
+#include "upnpclient.h"
+
+CUPnPSocket::CUPnPSocket()
+{
+	struct sockaddr_in sockudp;
+	int opt=1;
+
+	m_socket = socket(PF_INET, SOCK_DGRAM, 0);
+	if (!m_socket)
+		throw std::runtime_error(std::string("create UDP socket"));
+
+	memset(&sockudp, 0, sizeof(struct sockaddr_in));
+	sockudp.sin_family = AF_INET;
+	sockudp.sin_addr.s_addr = INADDR_ANY;
+
+	if (setsockopt(m_socket, SOL_SOCKET, SO_REUSEADDR, &opt, sizeof(opt)))
+	{
+		close(m_socket);
+		throw std::runtime_error(std::string("socket option"));
+	}
+
+	if (bind(m_socket, (struct sockaddr*) &sockudp, sizeof(struct sockaddr_in)))
+	{
+		close(m_socket);
+		throw std::runtime_error(std::string("bind"));
+	}
+}
+
+CUPnPSocket::~CUPnPSocket()
+{
+	close(m_socket);
+}
+
+void CUPnPSocket::SetTTL(int ttl)
+{
+	int result;
+
+	result = setsockopt(m_socket, IPPROTO_IP, IP_TTL, (char *)&ttl, sizeof(ttl));
+	if (!result)
+		throw std::runtime_error(std::string("set ttl"));
+}
+
+std::vector<CUPnPDevice> CUPnPSocket::Discover(std::string service)
+{
+	struct sockaddr_in sockudp;
+	std::stringstream command, reply;
+	std::string commandstr, line;
+	std::vector<CUPnPDevice> devices;
+	int result;
+	std::string::size_type pos;
+	struct pollfd fds[1];
+	char bufr[1536];
+
+	memset(&sockudp, 0, sizeof(struct sockaddr_in));
+	sockudp.sin_family = AF_INET;
+	sockudp.sin_port = htons(MULTICAST_PORT);
+	sockudp.sin_addr.s_addr = inet_addr(MULTICAST_IP);
+
+	command << "M-SEARCH * HTTP/1.1\r\n" <<
+	           "HOST: " << MULTICAST_IP << ":" << MULTICAST_PORT << "\r\n" <<
+		   "ST: " << service << "\r\n" <<
+		   "MAN: \"ssdp:discover\"\r\n" <<
+		   "MX: 3\r\n" <<
+		   "\r\n";
+
+	commandstr = command.str();
+	result = sendto(m_socket, commandstr.c_str(), commandstr.size(), 0, (struct sockaddr*) &sockudp, sizeof(struct sockaddr_in));
+
+	if (result < 0) {
+		throw std::runtime_error(std::string(strerror(errno)));
+	}
+//	result = sendto(m_socket, commandstr.c_str(), commandstr.size(), 0, (struct sockaddr*) &sockudp, sizeof(struct sockaddr_in));
+
+	fds[0].fd = m_socket;
+	fds[0].events = POLLIN;
+
+	for(;;)
+	{
+		result = poll(fds, 1, 4000);
+		if (result < 0)
+			throw std::runtime_error(std::string("poll"));
+		if (result == 0)
+			return devices;
+
+		result = recv(m_socket, bufr, sizeof(bufr), 0);
+		if (result < 0)
+			throw std::runtime_error(std::string("recv"));
+
+		bufr[result]=0;
+
+		reply.clear();
+		reply.str(std::string(bufr));
+
+		while (!reply.eof())
+		{
+			getline(reply, line);
+			pos=line.find("\r", 0);
+			if (pos!=std::string::npos)
+				line.erase(pos);
+			std::string location = line.substr(0,9);
+			if (!strcasecmp(location.c_str(), "location:"))
+			{
+				line.erase(0, 9);
+				while ((line.length() > 0 )&& ((line[0] == ' ') || (line[0] == '\t')))
+					line.erase(0, 1);
+				if (line.substr(0,7) == "http://")
+				{
+					std::vector<CUPnPDevice>::iterator i;
+					for (i=devices.begin(); i != devices.end(); ++i)
+						if (line == i->descurl)
+							goto found;
+					try
+					{
+						devices.push_back(CUPnPDevice(line));
+					}
+					catch (std::runtime_error error)
+					{
+						std::cout << "error " << error.what() << "\n";
+					}
+				}
+				found: ;
+			}
+		}
+	}
+}
diff -Naur 2379/lib/Makefile.am 2380/lib/Makefile.am
--- 2379/lib/Makefile.am	2014-12-31 15:52:18.000000000 +0100
+++ 2380/lib/Makefile.am	2014-12-31 15:53:26.000000000 +0100
@@ -8,7 +8,8 @@
 	libnet \
 	libxmltree \
 	libtuxtxt \
-	libdvbsub
+	libdvbsub \
+	libupnpclient
 
 if !BOXTYPE_COOLSTREAM
 SUBDIRS += libdvbapi
diff -Naur 2379/src/gui/Makefile.am 2380/src/gui/Makefile.am
--- 2379/src/gui/Makefile.am	2014-12-31 15:52:21.000000000 +0100
+++ 2380/src/gui/Makefile.am	2014-12-31 15:53:28.000000000 +0100
@@ -21,6 +21,7 @@
 	-I$(top_srcdir)/lib/libnet \
 	-I$(top_srcdir)/lib/libconfigfile \
 	-I$(top_srcdir)/lib/libxmltree \
+	-I$(top_srcdir)/lib/libupnpclient \
 	@CURL_CFLAGS@ \
 	@FREETYPE_CFLAGS@ 
 
@@ -50,7 +51,7 @@
 
 libneutrino_gui2_a_SOURCES = \
 	color.cpp motorcontrol.cpp hdd_menu.cpp \
-	alphasetup.cpp dvbsub_select.cpp psisetup.cpp opkg_manager.cpp webtv.cpp
+	alphasetup.cpp dvbsub_select.cpp psisetup.cpp opkg_manager.cpp webtv.cpp upnpbrowser.cpp
 
 if ENABLE_CI
 libneutrino_gui2_a_SOURCES += cam_menu.cpp
diff -Naur 2379/src/gui/upnpbrowser.cpp 2380/src/gui/upnpbrowser.cpp
--- 2379/src/gui/upnpbrowser.cpp	1970-01-01 01:00:00.000000000 +0100
+++ 2380/src/gui/upnpbrowser.cpp	2014-12-31 15:53:28.000000000 +0100
@@ -0,0 +1,1308 @@
+/*
+  Neutrino-GUI  -   DBoxII-Project
+
+  UPnP Browser (c) 2007 by Jochen Friedrich
+
+  Homepage: http://dbox.cyberphoria.org/
+
+  Kommentar:
+
+  Diese GUI wurde von Grund auf neu programmiert und sollte nun vom
+  Aufbau und auch den Ausbaumoeglichkeiten gut aussehen. Neutrino basiert
+  auf der Client-Server Idee, diese GUI ist also von der direkten DBox-
+  Steuerung getrennt. Diese wird dann von Daemons uebernommen.
+
+
+  License: GPL
+
+  This program is free software; you can redistribute it and/or modify
+  it under the terms of the GNU General Public License as published by
+  the Free Software Foundation; either version 2 of the License, or
+  (at your option) any later version.
+
+  This program is distributed in the hope that it will be useful,
+  but WITHOUT ANY WARRANTY; without even the implied warranty of
+  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+  GNU General Public License for more details.
+
+  You should have received a copy of the GNU General Public License
+  along with this program; if not, write to the Free Software
+  Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+*/
+
+#ifdef HAVE_CONFIG_H
+#include <config.h>
+#endif
+
+#include <sstream>
+#include <stdexcept>
+
+#include <gui/upnpbrowser.h>
+
+#include <global.h>
+#include <neutrino.h>
+#include <xmltree.h>
+#include <upnpclient.h>
+
+#include <driver/encoding.h>
+#include <driver/fontrenderer.h>
+#include <driver/rcinput.h>
+#include <driver/audioplay.h>
+#include <driver/audiofile.h>
+#include <driver/audiometadata.h>
+
+#include <daemonc/remotecontrol.h>
+
+#include <gui/eventlist.h>
+#include <gui/color.h>
+#include <gui/infoviewer.h>
+
+#include <gui/widget/buttons.h>
+#include <gui/widget/icons.h>
+#include <gui/widget/menue.h>
+#include <gui/widget/messagebox.h>
+#include <gui/widget/hintbox.h>
+#include <gui/widget/stringinput.h>
+#include <gui/widget/stringinput_ext.h>
+
+#include <system/settings.h>
+#include <gui/pictureviewer.h>
+#include <gui/movieplayer.h>
+#include <gui/webtv.h>
+
+
+#ifdef ConnectLineBox_Width
+#undef ConnectLineBox_Width
+#endif
+#define ConnectLineBox_Width    15
+
+extern CPictureViewer * g_PicViewer;
+extern CMoviePlayerGui * moviePlayerGui;	// defined in neutrino.cpp
+extern CWebTV * webtv;
+
+const struct button_label RescanButton = {NEUTRINO_ICON_BUTTON_BLUE  , LOCALE_UPNPBROWSER_RESCAN};
+const struct button_label StopButton   = {NEUTRINO_ICON_BUTTON_RED, LOCALE_AUDIOPLAYER_STOP};
+const struct button_label PUpButton    = {NEUTRINO_ICON_BUTTON_GREEN, LOCALE_FILEBROWSER_NEXTPAGE};
+const struct button_label PDownButton  = {NEUTRINO_ICON_BUTTON_YELLOW, LOCALE_FILEBROWSER_PREVPAGE};
+
+
+CUpnpBrowserGui::CUpnpBrowserGui()
+{
+	m_socket = new CUPnPSocket();
+	m_frameBuffer = CFrameBuffer::getInstance();
+	m_playing_entry_is_shown = false;
+}
+
+CUpnpBrowserGui::~CUpnpBrowserGui()
+{
+	delete m_socket;
+}
+
+int CUpnpBrowserGui::exec(CMenuTarget* parent, const std::string & /*actionKey*/)
+{
+
+	CAudioPlayer::getInstance()->init();
+
+	if(parent)
+		parent->hide();
+
+	// tell neutrino we're in audio mode
+	CNeutrinoApp::getInstance()->handleMsg( NeutrinoMessages::CHANGEMODE , NeutrinoMessages::mode_audio);
+	
+	// remember last mode
+	m_LastMode = (CNeutrinoApp::getInstance()->getLastMode());
+
+	m_width = (g_settings.screen_EndX - g_settings.screen_StartX) - ConnectLineBox_Width;
+	m_height = (g_settings.screen_EndY - g_settings.screen_StartY);
+	
+	m_frameBuffer->getIconSize(NEUTRINO_ICON_UPNP, &icon_head_w, &icon_head_h);
+
+	m_sheight = g_Font[SNeutrinoSettings::FONT_TYPE_INFOBAR_SMALL]->getHeight();
+	m_frameBuffer->getIconSize(NEUTRINO_ICON_BUTTON_OKAY, &icon_foot_w, &icon_foot_h);
+	m_buttonHeight = std::max(icon_foot_h, m_sheight) + 6;
+	m_theight = g_Font[SNeutrinoSettings::FONT_TYPE_MENU_TITLE]->getHeight();
+	m_mheight = g_Font[SNeutrinoSettings::FONT_TYPE_MENU]->getHeight();
+	m_fheight = g_Font[SNeutrinoSettings::FONT_TYPE_FILEBROWSER_ITEM]->getHeight();
+	m_title_height = m_mheight*2 + 20 + m_sheight + 4;
+	m_info_height = m_mheight*2;
+	m_listmaxshow = (m_height - m_info_height - m_title_height - m_theight - 2*m_buttonHeight) / (m_fheight);
+	m_height = m_theight + m_info_height + m_title_height + 2*m_buttonHeight + m_listmaxshow * m_fheight; // recalc height
+
+	m_x = (((g_settings.screen_EndX - g_settings.screen_StartX) - (m_width + ConnectLineBox_Width)) / 2) + g_settings.screen_StartX + ConnectLineBox_Width;
+	m_y = (((g_settings.screen_EndY- g_settings.screen_StartY) - m_height)/ 2) + g_settings.screen_StartY;
+
+	//
+	if(CNeutrinoApp::getInstance()->getLastMode() == NeutrinoMessages::mode_iptv)
+	{
+		if(webtv)
+			webtv->stopPlayBack();
+	}
+	else
+	{
+		// stop playback
+		g_Zapit->lockPlayBack();
+		
+		// Stop sectionsd
+		g_Sectionsd->setPauseScanning(true);
+	}
+
+	m_indexdevice = 0;
+	m_selecteddevice = 0;
+
+	selectDevice();
+
+	//
+	if(CAudioPlayer::getInstance()->getState() != CBaseDec::STOP)
+		CAudioPlayer::getInstance()->stop();
+	
+	//
+	if(CNeutrinoApp::getInstance()->getLastMode() == NeutrinoMessages::mode_iptv)
+	{
+		if(webtv)
+			webtv->startPlayBack(webtv->getTunedChannel());
+	}
+	else
+	{
+		// start playback
+		g_Zapit->unlockPlayBack();
+
+		// Start Sectionsd
+		g_Sectionsd->setPauseScanning(false);
+	}
+
+	CNeutrinoApp::getInstance()->handleMsg( NeutrinoMessages::CHANGEMODE , m_LastMode );
+	g_RCInput->postMsg( NeutrinoMessages::SHOW_INFOBAR, 0 );
+
+	// always repaint
+	return menu_return::RETURN_REPAINT;
+}
+
+void CUpnpBrowserGui::splitProtocol(std::string &protocol, std::string &prot, std::string &network, std::string &mime, std::string &additional)
+{
+	std::string::size_type pos;
+	std::string::size_type startpos = 0;
+
+	pos = protocol.find(":", startpos);
+	if (pos != std::string::npos)
+	{
+		prot = protocol.substr(startpos, pos-startpos);
+		startpos = pos + 1;
+
+		pos = protocol.find(":", startpos);
+		if (pos != std::string::npos)
+		{
+			network = protocol.substr(startpos, pos-startpos);
+			startpos = pos + 1;
+
+			pos = protocol.find(":", startpos);
+			if (pos != std::string::npos)
+			{
+				mime = protocol.substr(startpos, pos-startpos);
+				startpos = pos + 1;
+
+				pos = protocol.find(":", startpos);
+				if (pos != std::string::npos)
+				{
+					additional = protocol.substr(startpos, pos-startpos);
+				}
+			}
+		}
+	}
+	//printf("%s -> %s - %s - %s - %s\n", protocol.c_str(), prot.c_str(), network.c_str(), mime.c_str(), additional.c_str());
+}
+
+std::vector<UPnPEntry> *CUpnpBrowserGui::decodeResult(std::string result)
+{
+	XMLTreeParser * parser;
+	XMLTreeNode   * root, * node, * snode;
+	std::vector<UPnPEntry> * entries;
+
+	parser = new XMLTreeParser("UTF-8");
+	parser->Parse(result.c_str(), result.size(), 1);
+	root=parser->RootNode();
+	if (!root){
+		delete parser;
+		return NULL;
+	}
+	entries = new std::vector<UPnPEntry>;
+
+	for (node = root->GetChild(); node; node = node->GetNext())
+	{
+		bool isdir;
+		std::string title, artist = "", album = "", id, children;
+		char *type, *p;
+
+		if (!strcmp(node->GetType(), "container"))
+		{
+			std::vector<UPnPResource> resources;
+			isdir=true;
+			for (snode=node->GetChild(); snode; snode=snode->GetNext())
+			{
+				type=snode->GetType();
+				p = strchr(type,':');
+				if (p)
+					type=p+1;
+				if (!strcmp(type,"title"))
+				{
+					p=snode->GetData();
+					if (!p)
+						p=(char *) "";
+					title=std::string(p);
+				}
+			}
+			p = node->GetAttributeValue((char *) "id");
+			if (!p)
+				p=(char *) "";
+			id=std::string(p);
+
+			p = node->GetAttributeValue((char *) "childCount");
+			if (!p)
+				p=(char *) "";
+			children=std::string(p);
+
+			UPnPEntry entry={id, isdir, title, artist, album, children, resources, -1};
+			entries->push_back(entry);
+		}
+		
+		if (!strcmp(node->GetType(), "item"))
+		{
+			std::vector<UPnPResource> resources;
+			int preferred = -1;
+			std::string protocol, prot, network, mime, additional;
+			isdir=false;
+			for (snode=node->GetChild(); snode; snode=snode->GetNext())
+			{
+				std::string duration, url, size;
+				unsigned int i;
+				type=snode->GetType();
+				p = strchr(type,':');
+				if (p)
+					type=p+1;
+
+				if (!strcmp(type,"title"))
+				{
+					p=snode->GetData();
+					if (!p)
+						p=(char *) "";
+					title=std::string(p);
+				}
+				else if (!strcmp(type,"artist"))
+				{
+					p=snode->GetData();
+					if (!p)
+						p=(char *) "";
+					artist=std::string(p);
+				}
+				else if (!strcmp(type,"album"))
+				{
+					p=snode->GetData();
+					if (!p)
+						p=(char *) "";
+					album=std::string(p);
+				}
+				else if (!strcmp(type,"res"))
+				{
+					p = snode->GetData();
+					if (!p)
+						p=(char *) "";
+					url=std::string(p);
+					p = snode->GetAttributeValue((char *) "size");
+					if (!p)
+						p=(char *) "0";
+					size=std::string(p);
+					p = snode->GetAttributeValue((char *) "duration");
+					if (!p)
+						p=(char *) "";
+					duration=std::string(p);
+					p = snode->GetAttributeValue((char *) "protocolInfo");
+					if (!p)
+						p=(char *) "";
+					protocol=std::string(p);
+					UPnPResource resource = {url, protocol, size, duration};
+					resources.push_back(resource);
+				}
+				int pref=0;
+				preferred = -1;
+				
+				for (i = 0; i < resources.size(); i++)
+				{
+					protocol = resources[i].protocol;
+					splitProtocol(protocol, prot, network, mime, additional);
+					if (prot != "http-get")
+						continue;
+					
+					if (mime == "image/jpeg" && pref < 1)
+					{
+						preferred = i;
+						pref = 1;
+					}
+					if (mime == "image/gif" && pref < 2)
+					{
+						preferred = i;
+						pref = 2;
+					}
+
+					if (mime == "audio/mpeg" && pref < 3)
+					{
+						preferred = i;
+						pref = 3;
+					}
+					
+					if (mime == "audio/x-vorbis+ogg" && pref < 4)
+					{
+						preferred=i;
+						pref = 4;
+					}
+					
+					//
+					if (mime.substr(0,6) == "video/" && pref < 5)
+					{
+						preferred = i;
+						pref = 5;
+					}
+					
+					if (mime == "video/x-flv" && pref < 6)
+					{
+						preferred=i;
+						pref = 6;
+					}
+					
+					if (mime == "video/mp4" && pref < 7)
+					{
+						preferred=i;
+						pref = 7;
+					}
+					//
+				}
+			}
+			p = node->GetAttributeValue((char *) "id");
+			if (!p)
+				p=(char *) "";
+			id=std::string(p);
+
+			p = node->GetAttributeValue((char *) "childCount");
+			if (!p)
+				p=(char *) "";
+			children=std::string(p);
+
+			UPnPEntry entry={id, isdir, title, artist, album, children, resources, preferred};
+
+			entries->push_back(entry);
+		}
+	}
+	delete parser;
+	return entries;
+}
+
+void CUpnpBrowserGui::selectDevice()
+{
+	bool loop = true;
+	bool changed = true;
+	neutrino_msg_t      msg;
+	neutrino_msg_data_t data;
+
+	CHintBox *scanBox = new CHintBox(LOCALE_MESSAGEBOX_INFO, g_Locale->getText(LOCALE_UPNPBROWSER_SCANNING)); // UTF-8
+	scanBox->paint();
+
+	m_devices = m_socket->Discover("urn:schemas-upnp-org:service:ContentDirectory:1");
+	scanBox->hide();
+
+	if (!m_devices.size())
+	{
+		ShowLocalizedMessage(LOCALE_MESSAGEBOX_INFO, LOCALE_UPNPBROWSER_NOSERVERS, CMessageBox::mbrBack, CMessageBox::mbBack, NEUTRINO_ICON_UPDATE);
+		delete scanBox;
+		return;
+	}	
+
+	// control loop
+	while (loop)
+	{
+		if (changed)
+		{
+			paintDevice();
+			changed = false;
+		}
+		
+		m_frameBuffer->blit();
+
+		g_RCInput->getMsg(&msg, &data, 10); // 1 sec timeout to update play/stop state display
+		neutrino_msg_t msg_repeatok = msg & ~CRCInput::RC_Repeat;
+
+		if( msg == CRCInput::RC_timeout)
+		{
+			// nothing
+		}
+		else if( msg == CRCInput::RC_home)
+		{
+			loop = false;
+		}
+		else if (msg_repeatok == CRCInput::RC_up && m_selecteddevice > 0)
+		{
+			m_selecteddevice--;
+			if (m_selecteddevice < m_indexdevice)
+				m_indexdevice -= m_listmaxshow;
+			changed = true;
+		}
+		else if (msg_repeatok == CRCInput::RC_down && m_selecteddevice + 1 < m_devices.size())
+		{
+			m_selecteddevice++;
+			if (m_selecteddevice + 1 > m_indexdevice + m_listmaxshow)
+				m_indexdevice += m_listmaxshow;
+			changed = true;
+		}
+		else if( msg == CRCInput::RC_right || msg == CRCInput::RC_ok)
+		{
+			m_folderplay = false;
+			selectItem("0");
+			changed = true;
+		}
+		else if( msg == CRCInput::RC_blue)
+		{
+			scanBox->paint();
+
+			m_devices = m_socket->Discover("urn:schemas-upnp-org:service:ContentDirectory:1");
+			scanBox->hide();
+			if (!m_devices.size())
+			{
+				ShowLocalizedMessage(LOCALE_MESSAGEBOX_INFO, LOCALE_UPNPBROWSER_NOSERVERS, CMessageBox::mbrBack, CMessageBox::mbBack, NEUTRINO_ICON_UPDATE);
+				delete scanBox;
+				return;
+			}
+			changed = true;
+		}
+		else if(msg == NeutrinoMessages::RECORD_START ||
+			msg == NeutrinoMessages::ZAPTO ||
+			msg == NeutrinoMessages::STANDBY_ON ||
+			msg == NeutrinoMessages::SHUTDOWN ||
+			msg == NeutrinoMessages::SLEEPTIMER)
+		{
+			loop = false;
+			g_RCInput->postMsg(msg, data);
+		}
+		else if(msg == NeutrinoMessages::EVT_TIMER)
+		{
+			CNeutrinoApp::getInstance()->handleMsg( msg, data );
+		}
+		else
+		{
+			if( CNeutrinoApp::getInstance()->handleMsg( msg, data ) & messages_return::cancel_all )
+				loop = false;
+			changed = true;
+		}
+	
+		m_frameBuffer->blit();	
+	}
+	
+	delete scanBox;
+	
+	m_frameBuffer->ClearFrameBuffer();
+	m_frameBuffer->blit();
+}
+
+void CUpnpBrowserGui::playnext(void)
+{
+	while (true)
+	{
+		std::list<UPnPAttribute>attribs;
+		std::list<UPnPAttribute>results;
+		std::list<UPnPAttribute>::iterator i;
+		std::stringstream sindex;
+		std::vector<UPnPEntry> *entries = NULL;
+		bool rfound = false;
+		bool nfound = false;
+		bool tfound = false;
+
+		sindex << m_playid;
+		attribs.push_back(UPnPAttribute("ObjectID", m_playfolder));
+		attribs.push_back(UPnPAttribute("BrowseFlag", "BrowseDirectChildren"));
+		attribs.push_back(UPnPAttribute("Filter", "*"));
+		attribs.push_back(UPnPAttribute("StartingIndex", sindex.str()));
+		attribs.push_back(UPnPAttribute("RequestedCount", "1"));
+		attribs.push_back(UPnPAttribute("SortCriteria", ""));
+
+		results=m_devices[m_selecteddevice].SendSOAP("urn:schemas-upnp-org:service:ContentDirectory:1", "Browse", attribs);
+		for (i = results.begin(); i!=results.end(); i++)
+		{
+			if (i->first=="NumberReturned")
+			{
+				if (atoi(i->second.c_str()) != 1)
+				{
+					m_folderplay = false;
+					return;
+				}
+				nfound=true;
+			}
+			
+			if (i->first=="TotalMatches")
+			{
+				tfound=true;
+			}
+			
+			if (i->first=="Result")
+			{
+				entries=decodeResult(i->second);
+				rfound=true;
+			}
+		}
+		m_playid++;
+		
+		if ((entries != NULL) && (!(*entries)[0].isdir))
+		{
+			int preferred=(*entries)[0].preferred;
+			if (preferred != -1)
+			{
+				std::string protocol, prot, network, mime, additional;
+				protocol=(*entries)[0].resources[preferred].protocol;
+				splitProtocol(protocol, prot, network, mime, additional);
+				
+				if (mime == "audio/mpeg")
+				{
+					m_playing_entry = (*entries)[0];
+					m_playing_entry_is_shown = false;
+					CAudiofile mp3((*entries)[0].resources[preferred].url, CFile::FILE_MP3);
+					CAudioPlayer::getInstance()->play(&mp3, g_settings.audioplayer_highprio == 1);
+					return;
+				}
+				else if (mime == "audio/x-vorbis+ogg")
+				{
+					m_playing_entry = (*entries)[0];
+					m_playing_entry_is_shown = false;
+					CAudiofile mp3((*entries)[0].resources[preferred].url, CFile::FILE_OGG);
+					CAudioPlayer::getInstance()->play(&mp3, g_settings.audioplayer_highprio == 1);
+					return;
+				}
+				#if 0
+				else if (mime.substr(0,6) == "video/")
+				{
+					// /*g_settings.streaming_server_url*/moviePlayerGui->filename = std::string((*entries)[0].resources[preferred].url); //FIXME
+					moviePlayerGui->filename = (*entries)[0].resources[preferred].url.c_str(); //FIXME
+					if (CAudioPlayer::getInstance()->getState() != CBaseDec::STOP)
+						CAudioPlayer::getInstance()->stop();
+					moviePlayerGui->exec(NULL, "urlplayback");
+					return;
+				}
+				else if (mime.substr(0,6) == "image/")
+				{
+					g_PicViewer->SetScaling((CFrameBuffer::ScalingMode)g_settings.picviewer_scaling);
+					g_PicViewer->SetVisible(g_settings.screen_StartX, g_settings.screen_EndX, g_settings.screen_StartY, g_settings.screen_EndY);
+
+					if (g_settings.video_Format == 1)
+						g_PicViewer->SetAspectRatio(16.0/9);
+					else
+						g_PicViewer->SetAspectRatio(4.0/3);
+
+					g_PicViewer->ShowImage((*entries)[0].resources[preferred].url, false);
+					
+					return;
+				}
+				#endif
+			}
+		} 
+		else 
+		{
+			neutrino_msg_t      msg;
+			neutrino_msg_data_t data;
+			g_RCInput->getMsg(&msg, &data, 10); // 1 sec timeout to update play/stop state display
+
+			if( msg == CRCInput::RC_home)
+			{
+				m_folderplay = false;
+				break;
+			}
+		}
+	}
+	
+	//
+	m_frameBuffer->ClearFrameBuffer();
+	m_frameBuffer->blit();
+}
+
+bool CUpnpBrowserGui::selectItem(std::string id)
+{
+	bool loop = true;
+	bool endall = false;
+	bool changed = true;
+	bool rchanged = true;
+	neutrino_msg_t      msg;
+	neutrino_msg_data_t data;
+	std::vector<UPnPEntry> *entries;
+	unsigned int index, selected, dirnum;
+
+	index = 0;
+	selected = 0;
+	dirnum = 0;
+	entries = NULL;
+
+	while (loop)
+	{
+		updateTimes();		
+		
+		if (rchanged)
+		{
+			if (entries)
+				delete entries;
+			
+			entries = NULL;
+
+			std::list<UPnPAttribute>attribs;
+			std::list<UPnPAttribute>results;
+			std::list<UPnPAttribute>::iterator i;
+			std::stringstream sindex;
+			std::stringstream scount;
+			unsigned int returned = 0;
+
+			bool rfound = false;
+			bool nfound = false;
+			bool tfound = false;
+
+			sindex << index;
+			scount << m_listmaxshow;
+
+			attribs.push_back(UPnPAttribute("ObjectID", id));
+			attribs.push_back(UPnPAttribute("BrowseFlag", "BrowseDirectChildren"));
+			attribs.push_back(UPnPAttribute("Filter", "*"));
+			attribs.push_back(UPnPAttribute("StartingIndex", sindex.str()));
+			attribs.push_back(UPnPAttribute("RequestedCount", scount.str()));
+			attribs.push_back(UPnPAttribute("SortCriteria", ""));
+
+			results=m_devices[m_selecteddevice].SendSOAP("urn:schemas-upnp-org:service:ContentDirectory:1", "Browse", attribs);
+			for (i=results.begin(); i!=results.end(); i++)
+			{
+				if (i->first == "NumberReturned")
+				{
+					returned = atoi(i->second.c_str());
+					nfound = true;
+				}
+				if (i->first == "TotalMatches")
+				{
+					dirnum = atoi(i->second.c_str());
+					tfound = true;
+				}
+				if (i->first == "Result")
+				{
+					entries = decodeResult(i->second);
+					rfound = true;
+				}
+			}
+			if (!entries)
+				return endall;
+			if (!nfound || !tfound || !rfound)
+			{
+				delete entries;
+				return endall;
+			}
+			if (returned != entries->size())
+			{
+				delete entries;
+				return endall;
+			}
+
+			if (returned == 0)
+			{
+				delete entries;
+				return endall;
+			}
+			rchanged=false;
+			changed=true;
+		}
+
+		if (changed)
+		{
+			paintItem(entries, selected - index, dirnum - index, index);
+			changed = false;
+		}
+		
+		m_frameBuffer->blit();
+
+		g_RCInput->getMsg(&msg, &data, 10); // 1 sec timeout to update play/stop state display
+		neutrino_msg_t msg_repeatok = msg & ~CRCInput::RC_Repeat;
+
+		if( msg == CRCInput::RC_timeout)
+		{
+			// nothing
+		}
+		else if(msg == CRCInput::RC_home)
+		{
+			loop = false;
+			endall = true;
+		}
+		else if(msg == CRCInput::RC_left)
+		{
+			loop = false;
+		}
+
+		else if (msg_repeatok == CRCInput::RC_up && selected > 0)
+		{
+			selected--;
+			if (selected < index)
+			{
+				index -= m_listmaxshow;
+				rchanged = true;
+			}
+			changed=true;
+		}
+
+		else if( (msg == CRCInput::RC_yellow/*green*/ || (int) msg == g_settings.key_channelList_pageup) && selected > 0)
+		{
+			if (index > 0)
+			{
+				index-=m_listmaxshow;
+				selected-=m_listmaxshow;
+				rchanged=true;
+			}
+			else
+				selected=0;
+			changed = true;
+		}
+		else if (msg_repeatok == CRCInput::RC_down && selected + 1 < dirnum)
+		{
+			selected++;
+			if (selected + 1 > index + m_listmaxshow)
+			{
+				index += m_listmaxshow;
+				rchanged = true;
+			}
+			changed=true;
+		}
+		else if( (msg == CRCInput::RC_green/*red*/ || (int) msg == g_settings.key_channelList_pagedown)&& selected + 1 < dirnum)
+		{
+			if (index < ((dirnum - 1) / m_listmaxshow) * m_listmaxshow)
+			{
+				index += m_listmaxshow;
+				selected += m_listmaxshow;
+				if (selected + 1 >= dirnum)
+					selected = dirnum - 1;
+				rchanged = true;
+			}
+			else
+				selected = dirnum - 1;
+			changed = true;
+		}
+		else if(msg == CRCInput::RC_right)
+		{
+			if ((*entries)[selected - index].isdir)
+			{
+				endall = selectItem((*entries)[selected - index].id);
+				if (endall)
+					loop = false;
+			}
+			changed = true;
+		}
+		else if(msg == CRCInput::RC_ok)
+		{
+			if (!(*entries)[selected - index].isdir)
+			{
+				m_folderplay = false;
+				
+				int preferred=(*entries)[selected - index].preferred;
+				if (preferred != -1)
+				{
+					std::string protocol, prot, network, mime, additional;
+					protocol=(*entries)[selected - index].resources[preferred].protocol;
+					splitProtocol(protocol, prot, network, mime, additional);
+					
+					if (mime == "audio/mpeg")
+					{
+						CAudiofile mp3((*entries)[selected - index].resources[preferred].url, CFile::FILE_MP3);
+						CAudioPlayer::getInstance()->play(&mp3, g_settings.audioplayer_highprio == 1);
+					}
+					else if (mime == "audio/x-vorbis+ogg")
+					{
+						CAudiofile mp3((*entries)[selected - index].resources[preferred].url, CFile::FILE_OGG);
+						CAudioPlayer::getInstance()->play(&mp3, g_settings.audioplayer_highprio == 1);
+					}
+					else if ((mime == "image/gif") || (mime == "image/jpeg"))
+					{
+						bool _loop = true;
+						
+						g_PicViewer->SetScaling((CFrameBuffer::ScalingMode)g_settings.picviewer_scaling);
+						g_PicViewer->SetVisible(g_settings.screen_StartX, g_settings.screen_EndX, g_settings.screen_StartY, g_settings.screen_EndY);
+
+						if(g_settings.video_Ratio == 1)
+							g_PicViewer->SetAspectRatio(16.0/9);
+						else
+							g_PicViewer->SetAspectRatio(4.0/3);
+
+
+						g_PicViewer->ShowImage((*entries)[selected - index].resources[preferred].url);
+						
+						while (_loop)
+						{
+							g_RCInput->getMsg(&msg, &data, 10); // 1 sec timeout to update play/stop state display
+
+							if( msg == CRCInput::RC_home)
+								_loop = false;
+						}
+					
+						m_frameBuffer->ClearFrameBuffer();
+						m_frameBuffer->blit();	
+
+						changed = true;
+					}
+
+					else if (mime.substr(0,6) == "video/")
+					{
+						m_frameBuffer->ClearFrameBuffer();
+						m_frameBuffer->blit();	
+						
+						moviePlayerGui->filename = (*entries)[selected - index].resources[preferred].url.c_str(); //FIXME
+						moviePlayerGui->exec(NULL, "urlplayback");
+						
+						//test
+						// stop playback
+						g_Zapit->lockPlayBack();
+						
+						changed = true;
+					}
+					
+					m_playing_entry = (*entries)[selected - index];
+				}
+
+			} 
+			else 
+			{
+				m_folderplay = true;
+				m_playfolder = (*entries)[selected - index].id;
+				m_playid = 0;
+				playnext();
+			}
+			
+			changed = true;
+		}
+		else if( msg == CRCInput::RC_red/*yellow*/)
+		{
+			if(CAudioPlayer::getInstance()->getState() != CBaseDec::STOP)
+				CAudioPlayer::getInstance()->stop();
+			m_folderplay = false;
+		}
+		else if(msg == NeutrinoMessages::RECORD_START ||
+			msg == NeutrinoMessages::ZAPTO ||
+			msg == NeutrinoMessages::STANDBY_ON ||
+			msg == NeutrinoMessages::SHUTDOWN ||
+			msg == NeutrinoMessages::SLEEPTIMER)
+		{
+			loop = false;
+			g_RCInput->postMsg(msg, data);
+		}
+
+		else if(msg == NeutrinoMessages::EVT_TIMER)
+		{
+			CNeutrinoApp::getInstance()->handleMsg( msg, data );
+		}
+		else
+		{
+			if( CNeutrinoApp::getInstance()->handleMsg( msg, data ) & messages_return::cancel_all )
+				loop = false;
+			changed = true;
+		}
+
+		if (m_folderplay && (CAudioPlayer::getInstance()->getState() == CBaseDec::STOP))
+			playnext();
+								
+		m_frameBuffer->blit();	
+	}
+	
+	if (entries)
+		delete entries;
+	
+	m_frameBuffer->ClearFrameBuffer();
+	m_frameBuffer->blit();
+	
+	return endall;
+}
+
+void CUpnpBrowserGui::paintDevicePos(unsigned int pos)
+{
+	int ypos = m_y + m_title_height + m_theight + pos*m_fheight;
+	uint8_t    color;
+	fb_pixel_t bgcolor;
+
+	if (pos == m_selecteddevice)
+	{
+		color   = COL_MENUCONTENT + 2;
+		bgcolor = COL_MENUCONTENT_PLUS_2;
+	}
+	else
+	{
+		color   = COL_MENUCONTENT;
+		bgcolor = COL_MENUCONTENT_PLUS_0;
+	}
+	m_frameBuffer->paintBoxRel(m_x, ypos, m_width - 15, m_fheight, bgcolor);
+
+	if (pos + m_indexdevice >= m_devices.size())
+		return;
+
+	char sNr[20];
+	sprintf(sNr, "%2d", pos + 1);
+	std::string num = sNr;
+
+	std::string name = m_devices[pos + m_indexdevice].friendlyname;
+
+	int w = g_Font[SNeutrinoSettings::FONT_TYPE_FILEBROWSER_ITEM]->getRenderWidth(name) + 5;
+	g_Font[SNeutrinoSettings::FONT_TYPE_FILEBROWSER_ITEM]->RenderString(m_x + 10, ypos + m_fheight, m_width - 30 - w, num, color, m_fheight, true); // UTF-8
+	g_Font[SNeutrinoSettings::FONT_TYPE_FILEBROWSER_ITEM]->RenderString(m_x + m_width - 15 - w, ypos + m_fheight, w, name, color, m_fheight, true); // UTF-8
+}
+
+void CUpnpBrowserGui::paintItemPos(std::vector<UPnPEntry> *entry, unsigned int pos, unsigned int selected)
+{
+	int ypos = m_y + m_title_height + m_theight + pos*m_fheight;
+	uint8_t    color;
+	fb_pixel_t bgcolor;
+
+	if (pos == selected)
+	{
+		color   = COL_MENUCONTENT + 2;
+		bgcolor = COL_MENUCONTENT_PLUS_2;
+		paintDetails(entry, pos);
+		if ((*entry)[pos].isdir)
+			paintItem2DetailsLine (-1, pos); // clear it
+		else
+			paintItem2DetailsLine (pos, pos);
+	}
+	else
+	{
+		color   = COL_MENUCONTENT;
+		bgcolor = COL_MENUCONTENT_PLUS_0;
+	}
+	
+	m_frameBuffer->paintBoxRel(m_x, ypos, m_width - 15, m_fheight, bgcolor);
+
+	if (pos >= entry->size())
+		return;
+
+	int preferred=(*entry)[pos].preferred;
+	std::string info;
+	std::string fileicon;
+	if ((*entry)[pos].isdir)
+	{
+		info = "<DIR>";
+		fileicon = NEUTRINO_ICON_FOLDER;
+	}
+	else
+	{
+		//FIXME: revise this
+		if (preferred != -1)
+		{
+			info = (*entry)[pos].resources[preferred].duration;
+			//FIXME
+			fileicon = NEUTRINO_ICON_MP3;
+		}
+		else
+		{
+			info = "(none)";
+			fileicon = NEUTRINO_ICON_FILE;
+		}
+	}
+
+	std::string name = (*entry)[pos].title;
+	char tmp_time[] = "00:00:00.0";
+	int w = g_Font[SNeutrinoSettings::FONT_TYPE_FILEBROWSER_ITEM]->getRenderWidth(tmp_time);
+
+	m_frameBuffer->paintIcon(fileicon, m_x + 5 , ypos + (m_fheight - 16) / 2);
+	g_Font[SNeutrinoSettings::FONT_TYPE_FILEBROWSER_ITEM]->RenderString(m_x + m_width - 15 - w, ypos + m_fheight, w, info, color, m_fheight);
+	g_Font[SNeutrinoSettings::FONT_TYPE_FILEBROWSER_ITEM]->RenderString(m_x + 30, ypos + m_fheight, m_width - 50 - w, name, color, m_fheight, true); // UTF-8
+}
+
+void CUpnpBrowserGui::paintDevice()
+{
+	std::string tmp;
+	int w, xstart, ypos, top;
+
+	// LCD
+	CVFD::getInstance()->setMode(CVFD::MODE_MENU_UTF8, "Select UPnP Device");
+	CVFD::getInstance()->showMenuText(0, m_devices[m_selecteddevice].friendlyname.c_str(), -1, true);
+
+	// Info
+	m_frameBuffer->paintBoxRel(m_x, m_y, m_width, m_title_height - 10, COL_MENUCONTENT_PLUS_6 );
+	m_frameBuffer->paintBoxRel(m_x + 2, m_y + 2, m_width - 4, m_title_height - 14, COL_MENUCONTENTSELECTED_PLUS_0 );
+
+	// first line
+	tmp = m_devices[m_selecteddevice].manufacturer + " " + m_devices[m_selecteddevice].manufacturerurl;
+	w = g_Font[SNeutrinoSettings::FONT_TYPE_MENU]->getRenderWidth(tmp, true); // UTF-8
+	xstart = (m_width - w) / 2;
+	if(xstart < 10)
+		xstart = 10;
+	g_Font[SNeutrinoSettings::FONT_TYPE_MENU]->RenderString(m_x + xstart, m_y + 4 + 1*m_mheight, m_width - 20, tmp, COL_MENUCONTENTSELECTED, 0, true); // UTF-8
+
+	// second line
+	tmp = m_devices[m_selecteddevice].modelname + " " +
+		m_devices[m_selecteddevice].modelnumber + " " +
+		m_devices[m_selecteddevice].modeldescription;
+	w = g_Font[SNeutrinoSettings::FONT_TYPE_MENU]->getRenderWidth(tmp, true); // UTF-8
+	xstart = (m_width - w) / 2;
+	if(xstart < 10)
+		xstart = 10;
+	g_Font[SNeutrinoSettings::FONT_TYPE_MENU]->RenderString(m_x + xstart, m_y + 4 + 2*m_mheight, m_width - 20, tmp, COL_MENUCONTENTSELECTED, 0, true); // UTF-8
+	// third line
+	tmp = m_devices[m_selecteddevice].modelurl;
+	w = g_Font[SNeutrinoSettings::FONT_TYPE_MENU]->getRenderWidth(tmp, true); // UTF-8
+	xstart = (m_width - w) / 2;
+	if(xstart < 10)
+		xstart = 10;
+	g_Font[SNeutrinoSettings::FONT_TYPE_MENU]->RenderString(m_x + xstart, m_y + 4 + 3*m_mheight, m_width - 20, tmp, COL_MENUCONTENTSELECTED, 0, true); // UTF-8
+
+	// Head
+	tmp = g_Locale->getText(LOCALE_UPNPBROWSER_HEAD);
+	m_frameBuffer->paintBoxRel(m_x, m_y + m_title_height, m_width, m_theight, COL_MENUHEAD_PLUS_0, RADIUS_MID, CORNER_TOP);
+	m_frameBuffer->paintIcon(NEUTRINO_ICON_UPNP, m_x + BORDER_LEFT, m_y + m_title_height + (m_theight -icon_head_h)/2);
+	g_Font[SNeutrinoSettings::FONT_TYPE_MENU_TITLE]->RenderString(m_x + BORDER_LEFT + icon_head_w + 5, m_y + m_theight + m_title_height + 0, m_width - 45, tmp, COL_MENUHEAD, 0, true); // UTF-8
+	ypos = m_y + m_title_height;
+	if(m_theight > icon_head_h)
+		ypos = (m_theight - icon_head_h) / 2 + m_y + m_title_height;
+
+	// Items
+	for (unsigned int count = 0; count < m_listmaxshow; count++)
+		paintDevicePos(count);
+
+	ypos = m_y + m_title_height + m_theight;
+	int sb = m_fheight * m_listmaxshow;
+	m_frameBuffer->paintBoxRel(m_x + m_width - SCROLLBAR_WIDTH, ypos, SCROLLBAR_WIDTH, sb, COL_MENUCONTENT_PLUS_1);
+
+	int sbc = ((m_devices.size() - 1) / m_listmaxshow) + 1;
+	int sbs = ((m_selecteddevice) / m_listmaxshow);
+
+	m_frameBuffer->paintBoxRel(m_x + m_width - 13, ypos + 2 + sbs*(sb-4)/sbc, 11, (sb-4)/sbc, COL_MENUCONTENT_PLUS_3);
+
+	// Foot
+	top = m_y + (m_height - m_info_height - 2*m_buttonHeight);
+
+	int ButtonWidth = (m_width - BORDER_LEFT - BORDER_RIGHT) / 4;
+	m_frameBuffer->paintBoxRel(m_x, top, m_width, m_buttonHeight, COL_MENUHEAD_PLUS_0, RADIUS_MID, CORNER_BOTTOM);
+	//m_frameBuffer->paintHLine(m_x, m_x + m_width, top, COL_INFOBAR_SHADOW_PLUS_0);
+	::paintButtons(m_frameBuffer, g_Font[SNeutrinoSettings::FONT_TYPE_INFOBAR_SMALL], g_Locale, m_x + BORDER_LEFT + 3*ButtonWidth, top + (m_buttonHeight - icon_foot_h)/2, ButtonWidth, 1, &RescanButton);
+
+	//clearItem2DetailsLine(); // clear it
+}
+
+void CUpnpBrowserGui::paintItem(std::vector<UPnPEntry> *entry, unsigned int selected, unsigned int max, unsigned int offset)
+{
+	std::string tmp;
+	std::stringstream ts;
+	int w, xstart, ypos, top;
+	int preferred=(*entry)[selected].preferred;
+
+	// LCD
+	CVFD::getInstance()->setMode(CVFD::MODE_MENU_UTF8, "Select UPnP Entry");
+	CVFD::getInstance()->showMenuText(0, (*entry)[selected].title.c_str(), -1, true);
+
+	// Info
+	m_frameBuffer->paintBoxRel(m_x, m_y, m_width, m_title_height - 10, COL_MENUCONTENT_PLUS_6);
+	m_frameBuffer->paintBoxRel(m_x + 2, m_y + 2, m_width - 4, m_title_height - 14, COL_MENUCONTENTSELECTED_PLUS_0);
+
+	// first line
+	ts << "Resources: " << (*entry)[selected].resources.size() << " Selected: " << preferred+1 << " ";
+	tmp = ts.str();
+
+	if (preferred != -1)
+		tmp = tmp + "Duration: " + (*entry)[selected].resources[preferred].duration;
+	else
+		tmp = tmp + "No resource for Item";
+	w = g_Font[SNeutrinoSettings::FONT_TYPE_MENU]->getRenderWidth(tmp, true); // UTF-8
+	if (w > m_width - 20)
+		w = m_width - 20;
+	xstart = (m_width - w) / 2;
+	if(xstart < 10)
+		xstart = 10;
+	g_Font[SNeutrinoSettings::FONT_TYPE_MENU]->RenderString(m_x + xstart, m_y + 4 + 1*m_mheight, m_width - 20, tmp, COL_MENUCONTENTSELECTED, 0, true); // UTF-8
+
+	// second line
+	if ((*entry)[selected].isdir)
+		tmp = "Directory";
+	else
+	{
+		tmp = "";
+		if (preferred != -1)
+		{
+			std::string proto, network, mime, info;
+			splitProtocol((*entry)[selected].resources[preferred].protocol, proto, network, mime, info);
+			tmp = "Protocol: " + proto + ", MIME-Type: " + mime;
+		}
+
+	}
+	w = g_Font[SNeutrinoSettings::FONT_TYPE_MENU]->getRenderWidth(tmp, true); // UTF-8
+	if (w > m_width - 20)
+		w = m_width - 20;
+	xstart = (m_width - w) / 2;
+	if(xstart < 10)
+		xstart = 10;
+	g_Font[SNeutrinoSettings::FONT_TYPE_MENU]->RenderString(m_x + xstart, m_y + 4 + 2*m_mheight, m_width - 20, tmp, COL_MENUCONTENTSELECTED, 0, true); // UTF-8
+
+	//third line
+	tmp = "";
+	if (!(*entry)[selected].isdir)
+	{
+		if (preferred != -1)
+		{
+			tmp = "URL: " + (*entry)[selected].resources[preferred].url;
+		}
+
+	}
+	w = g_Font[SNeutrinoSettings::FONT_TYPE_MENU]->getRenderWidth(tmp, true); // UTF-8
+	if (w > m_width - 20)
+		w = m_width - 20;
+	xstart = (m_width - w) / 2;
+	if(xstart < 10)
+		xstart = 10;
+	g_Font[SNeutrinoSettings::FONT_TYPE_MENU]->RenderString(m_x + xstart, m_y + 4 + 3*m_mheight, m_width - 20, tmp, COL_MENUCONTENTSELECTED, 0, true); // UTF-8
+
+
+	// Head
+	tmp = g_Locale->getText(LOCALE_UPNPBROWSER_HEAD);
+	m_frameBuffer->paintBoxRel(m_x, m_y + m_title_height, m_width, m_theight, COL_MENUHEAD_PLUS_0, RADIUS_MID, CORNER_TOP);
+	m_frameBuffer->paintIcon(NEUTRINO_ICON_UPNP, m_x + BORDER_LEFT, m_y + m_title_height + (m_theight - icon_head_h)/2);
+	g_Font[SNeutrinoSettings::FONT_TYPE_MENU_TITLE]->RenderString(m_x + BORDER_LEFT + icon_head_w + 5, m_y + m_theight + m_title_height, m_width - 45, tmp, COL_MENUHEAD, 0, true); // UTF-8
+	
+	//
+	ypos = m_y + m_title_height;
+	if(m_theight > icon_head_h)
+		ypos = (m_theight - icon_head_h) / 2 + m_y + m_title_height;
+
+	// Items
+	for (unsigned int count = 0; count < m_listmaxshow; count++)
+		paintItemPos(entry, count, selected);
+
+	ypos = m_y + m_title_height + m_theight;
+	int sb = m_fheight * m_listmaxshow;
+	m_frameBuffer->paintBoxRel(m_x + m_width - SCROLLBAR_WIDTH, ypos, SCROLLBAR_WIDTH, sb, COL_MENUCONTENT_PLUS_1);
+
+	int sbc = ((max + offset - 1) / m_listmaxshow) + 1;
+	int sbs = ((selected + offset) / m_listmaxshow);
+
+	int sbh = 0;
+	if ((sbc > 0) && (sbc > sb - 4))
+		sbh = 2;
+	m_frameBuffer->paintBoxRel(m_x + m_width - 13, ypos + 2 + sbs*((sb - 4)/sbc + sbh), 11, (sb - 4)/sbc + sbh, COL_MENUCONTENT_PLUS_3);
+
+	// Foot buttons
+	top = m_y + (m_height - m_info_height - 2*m_buttonHeight);
+	int ButtonWidth = (m_width - 20) / 4;
+	m_frameBuffer->paintBoxRel(m_x, top, m_width, m_buttonHeight, COL_MENUHEAD_PLUS_0, RADIUS_MID, CORNER_BOTTOM);
+	
+	::paintButtons(m_frameBuffer, g_Font[SNeutrinoSettings::FONT_TYPE_INFOBAR_SMALL], g_Locale, m_x + BORDER_LEFT, top + (m_buttonHeight - icon_foot_h)/2, ButtonWidth, 1, &StopButton);
+	::paintButtons(m_frameBuffer, g_Font[SNeutrinoSettings::FONT_TYPE_INFOBAR_SMALL], g_Locale, m_x + BORDER_LEFT + ButtonWidth, top + (m_buttonHeight - icon_foot_h)/2, ButtonWidth, 1, &PUpButton);
+	::paintButtons(m_frameBuffer, g_Font[SNeutrinoSettings::FONT_TYPE_INFOBAR_SMALL], g_Locale, m_x + BORDER_LEFT + 2*ButtonWidth, top + (m_buttonHeight - icon_foot_h)/2, ButtonWidth, 1, &PDownButton);
+
+	m_frameBuffer->paintIcon(NEUTRINO_ICON_BUTTON_OKAY, m_x + BORDER_LEFT + 3*ButtonWidth, top + (m_buttonHeight - icon_foot_h)/2);
+	g_Font[SNeutrinoSettings::FONT_TYPE_INFOBAR_SMALL]->RenderString(m_x + BORDER_LEFT + 3*ButtonWidth + icon_foot_w + 5, top + (m_buttonHeight - g_Font[SNeutrinoSettings::FONT_TYPE_INFOBAR_SMALL]->getHeight())/2 + g_Font[SNeutrinoSettings::FONT_TYPE_INFOBAR_SMALL]->getHeight(), ButtonWidth - 40, g_Locale->getText(LOCALE_AUDIOPLAYER_PLAY), COL_INFOBAR, 0, true); // UTF-8
+}
+
+void CUpnpBrowserGui::paintDetails(std::vector<UPnPEntry> *entry, unsigned int index, bool use_playing)
+{
+	// Foot info
+	int top = m_y + (m_height - m_info_height - 1*m_buttonHeight) + 2;
+
+	if ((!use_playing) && ((*entry)[index].isdir))
+	{
+		m_frameBuffer->paintBackgroundBoxRel(m_x + 2, top + 2, m_width - 4, 2*m_buttonHeight);
+	}
+	else
+	{
+		if (use_playing) 
+		{
+			if (!m_playing_entry_is_shown) 
+			{
+				m_frameBuffer->paintBoxRel(m_x + 2, top + 2, m_width - 4, 2*m_buttonHeight, COL_MENUCONTENTDARK_PLUS_0);
+				m_playing_entry_is_shown = true;
+				g_Font[SNeutrinoSettings::FONT_TYPE_FILEBROWSER_ITEM]->RenderString(m_x + 5, top + 2 + (m_buttonHeight - g_Font[SNeutrinoSettings::FONT_TYPE_FILEBROWSER_ITEM]->getHeight())/2 + g_Font[SNeutrinoSettings::FONT_TYPE_FILEBROWSER_ITEM]->getHeight(), m_x + m_width - 10, m_playing_entry.title + " - " + m_playing_entry.artist, COL_INFOBAR, 0, true); // UTF-8
+				g_Font[SNeutrinoSettings::FONT_TYPE_FILEBROWSER_ITEM]->RenderString(m_x + 5, top + 2 + m_buttonHeight + (m_buttonHeight - g_Font[SNeutrinoSettings::FONT_TYPE_FILEBROWSER_ITEM]->getHeight())/2 + g_Font[SNeutrinoSettings::FONT_TYPE_FILEBROWSER_ITEM]->getHeight(), m_x + m_width - 10, m_playing_entry.album, COL_INFOBAR, 0, true); // UTF-8
+			}
+		} 
+		else 
+		{
+			if (entry == NULL) 
+				return;
+			
+			m_frameBuffer->paintBoxRel(m_x + 2, top + 2, m_width - 4, 2*m_buttonHeight, COL_MENUCONTENTDARK_PLUS_0);
+			m_playing_entry_is_shown = false;
+			g_Font[SNeutrinoSettings::FONT_TYPE_FILEBROWSER_ITEM]->RenderString(m_x + 5, top + 2 + (m_buttonHeight - g_Font[SNeutrinoSettings::FONT_TYPE_FILEBROWSER_ITEM]->getHeight())/2 + g_Font[SNeutrinoSettings::FONT_TYPE_FILEBROWSER_ITEM]->getHeight(), m_x + m_width - 10, (*entry)[index].title + " - " + (*entry)[index].artist, COL_INFOBAR, 0, true); // UTF-8
+			g_Font[SNeutrinoSettings::FONT_TYPE_FILEBROWSER_ITEM]->RenderString(m_x + 5, top + m_buttonHeight + (m_buttonHeight - g_Font[SNeutrinoSettings::FONT_TYPE_FILEBROWSER_ITEM]->getHeight())/2 + g_Font[SNeutrinoSettings::FONT_TYPE_FILEBROWSER_ITEM]->getHeight(), m_x + m_width - 10, (*entry)[index].album, COL_INFOBAR, 0, true); // UTF-8
+		}
+	}
+}
+
+//
+// -- Decoreline to connect ChannelDisplayLine with ChannelDetail display
+// -- 2002-03-17 rasc
+//
+void CUpnpBrowserGui::clearItem2DetailsLine()
+{
+	paintItem2DetailsLine (-1, 0);
+}
+
+void CUpnpBrowserGui::paintItem2DetailsLine(int pos, unsigned int /*ch_index*/)
+{
+	int xpos  = m_x - ConnectLineBox_Width;
+	int ypos1 = m_y + m_title_height + m_theight + pos*m_fheight;
+	int ypos2 = m_y + (m_height - m_info_height - 1 * m_buttonHeight) + 2;
+
+	int ypos1a = ypos1 + (m_fheight/2)-2;
+	int ypos2a = ypos2 + (m_info_height/2) - 2;
+	fb_pixel_t col1 = COL_MENUCONTENT_PLUS_6;
+	fb_pixel_t col2 = COL_MENUCONTENT_PLUS_1;
+
+	// Clear
+	m_frameBuffer->paintBackgroundBoxRel(xpos, m_y + m_title_height, ConnectLineBox_Width, m_height + m_info_height - (m_y + m_title_height));
+	
+	if (pos < 0) 
+	{
+		m_frameBuffer->paintBackgroundBoxRel(m_x, m_y + (m_height - m_info_height - 1* m_buttonHeight) + 2, m_width, m_info_height);
+	}
+	
+	// paint Line if detail info (and not valid list pos)
+	if (pos >= 0)
+	{
+		// 1. col thick line
+		m_frameBuffer->paintBoxRel(xpos + ConnectLineBox_Width - 4,  ypos1, 4,  m_fheight,     col1);
+		m_frameBuffer->paintBoxRel(xpos + ConnectLineBox_Width - 4,  ypos2, 4,  m_info_height, col1);
+
+		m_frameBuffer->paintBoxRel(xpos + ConnectLineBox_Width - 15, ypos1a, 4, ypos2a - ypos1a, col1);
+
+		m_frameBuffer->paintBoxRel(xpos + ConnectLineBox_Width - 15, ypos1a, 12, 4, col1);
+		m_frameBuffer->paintBoxRel(xpos + ConnectLineBox_Width - 15, ypos2a, 12, 4, col1);
+
+		// 2. col small line
+		m_frameBuffer->paintBoxRel(xpos + ConnectLineBox_Width - 4, ypos1, 1, m_fheight, col2);
+		m_frameBuffer->paintBoxRel(xpos + ConnectLineBox_Width - 4, ypos2, 1, m_info_height, col2);
+
+		m_frameBuffer->paintBoxRel(xpos + ConnectLineBox_Width - 15, ypos1a, 1, ypos2a - ypos1a + 4, col2);
+
+		m_frameBuffer->paintBoxRel(xpos + ConnectLineBox_Width - 15, ypos1a, 12, 1, col2);
+		m_frameBuffer->paintBoxRel(xpos + ConnectLineBox_Width - 12, ypos2a, 8,  1, col2);
+
+		// -- small Frame around infobox
+		m_frameBuffer->paintBoxRel(m_x, ypos2, 2, m_info_height, col1);
+		m_frameBuffer->paintBoxRel(m_x+m_width-2, ypos2, 2, m_info_height, col1);
+		m_frameBuffer->paintBoxRel(m_x, ypos2, m_width - 2, 2, col1);
+		m_frameBuffer->paintBoxRel(m_x , ypos2 + m_info_height - 2, m_width - 2, 2, col1);
+	}
+}
+
+void CUpnpBrowserGui::updateTimes(const bool force)
+{
+	int top;
+	
+	if(CAudioPlayer::getInstance()->getState() != CBaseDec::STOP)
+	{
+		bool updatePlayed = force;
+
+		if ((m_time_played != CAudioPlayer::getInstance()->getTimePlayed()))
+		{
+			m_time_played = CAudioPlayer::getInstance()->getTimePlayed();
+			updatePlayed = true;
+		}
+		
+		char play_time[8];
+		snprintf(play_time, 7, "%ld:%02ld", m_time_played / 60, m_time_played % 60);
+		char tmp_time[] = "000:00";
+		int w = g_Font[SNeutrinoSettings::FONT_TYPE_INFOBAR_SMALL]->getRenderWidth(tmp_time);
+
+		if (updatePlayed)
+		{
+			paintDetails(NULL, 0, true);
+			top = m_y + (m_height - m_info_height - 1 * m_buttonHeight) + m_buttonHeight + 4;
+			m_frameBuffer->paintBoxRel(m_x + m_width - w - 15, top + 1, w + 4, m_buttonHeight, COL_MENUCONTENTDARK_PLUS_0);
+			g_Font[SNeutrinoSettings::FONT_TYPE_INFOBAR_SMALL]->RenderString(m_x + m_width - w - 11, top + 1 + m_buttonHeight, w, play_time, COL_MENUHEAD);			
+		}
+	}
+}
+
diff -Naur 2379/src/gui/upnpbrowser.h 2380/src/gui/upnpbrowser.h
--- 2379/src/gui/upnpbrowser.h	1970-01-01 01:00:00.000000000 +0100
+++ 2380/src/gui/upnpbrowser.h	2014-12-31 15:53:28.000000000 +0100
@@ -0,0 +1,121 @@
+/*
+  Neutrino-GUI  -   DBoxII-Project
+
+  Copyright (C) 2001 Steffen Hehn 'McClean'
+  Homepage: http://dbox.cyberphoria.org/
+
+  Kommentar:
+
+  Diese GUI wurde von Grund auf neu programmiert und sollte nun vom
+  Aufbau und auch den Ausbaumoeglichkeiten gut aussehen. Neutrino basiert
+  auf der Client-Server Idee, diese GUI ist also von der direkten DBox-
+  Steuerung getrennt. Diese wird dann von Daemons uebernommen.
+
+
+  License: GPL
+
+  This program is free software; you can redistribute it and/or modify
+  it under the terms of the GNU General Public License as published by
+  the Free Software Foundation; either version 2 of the License, or
+  (at your option) any later version.
+
+  This program is distributed in the hope that it will be useful,
+  but WITHOUT ANY WARRANTY; without even the implied warranty of
+  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+  GNU General Public License for more details.
+
+  You should have received a copy of the GNU General Public License
+  along with this program; if not, write to the Free Software
+  Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+*/
+
+#ifndef __upnpplayergui__
+#define __upnpplayergui__
+
+#include "driver/framebuffer.h"
+#include "driver/audiofile.h"
+#include "driver/pictureviewer/pictureviewer.h"
+#include "gui/filebrowser.h"
+#include "gui/widget/menue.h"
+
+#include <string>
+#include <sstream>
+#include <upnpclient.h>
+
+
+struct UPnPResource
+{
+	std::string	url;
+	std::string	protocol;
+	std::string	size;
+	std::string	duration;
+};
+
+struct UPnPEntry
+{
+	std::string	id;
+	bool		isdir;
+	std::string	title;
+	std::string	artist;
+	std::string	album;
+	std::string	children;
+	std::vector<UPnPResource> resources;
+	int		preferred;
+};
+
+class CUpnpBrowserGui : public CMenuTarget
+{
+	public:
+		CUpnpBrowserGui();
+		~CUpnpBrowserGui();
+		int exec(CMenuTarget* parent, const std::string & actionKey);
+
+	private:
+		std::vector<CUPnPDevice> m_devices;
+		UPnPEntry      m_playing_entry;
+		CUPnPSocket  * m_socket;
+		CFrameBuffer * m_frameBuffer;
+		//bool           m_vol_ost;
+		int            m_LastMode;
+		int            m_width;
+		int            m_height;
+		int            m_x;
+		int            m_y;
+		unsigned int   m_listmaxshow;
+		unsigned int   m_indexdevice;
+		unsigned int   m_selecteddevice;
+		int            m_fheight; // Fonthoehe Inhalt
+		int            m_theight; // Fonthoehe Titel
+		int            m_mheight; // Fonthoehe Info
+		int            m_sheight; // Fonthoehe Status
+		int            m_buttonHeight;
+		int            m_title_height;
+		int            m_info_height;
+		bool           m_folderplay;
+		std::string    m_playfolder;
+		int            m_playid;
+		time_t         m_time_played;
+		bool           m_playing_entry_is_shown;
+		
+		int icon_head_w;
+		int icon_head_h;
+		int icon_foot_w;
+		int icon_foot_h;
+
+		void selectDevice();
+		bool selectItem(std::string);
+		void paintItem(std::vector<UPnPEntry> *entry, unsigned int selected, unsigned int max, unsigned int offset);
+		void paintDevice();
+		std::vector<UPnPEntry> *decodeResult(std::string);
+		void playnext();
+		void splitProtocol(std::string &protocol, std::string &prot, std::string &network, std::string &mime, std::string &additional);
+		void paintItemPos  (std::vector<UPnPEntry> *entry, unsigned int pos, unsigned int selected);
+		void paintDevicePos(unsigned int pos);
+		void paintDetails(std::vector<UPnPEntry> *entry, unsigned int index, bool use_playing = false);
+		void clearItem2DetailsLine (void);
+		void paintItem2DetailsLine (int pos,unsigned  int ch_index);
+
+		void updateTimes(const bool force = false);
+};
+
+#endif
diff -Naur 2379/src/Makefile.am 2380/src/Makefile.am
--- 2379/src/Makefile.am	2014-12-31 15:52:23.000000000 +0100
+++ 2380/src/Makefile.am	2014-12-31 15:53:29.000000000 +0100
@@ -9,6 +9,7 @@
 	-I$(top_srcdir)/lib/libnet \
 	-I$(top_srcdir)/lib/libxmltree \
 	-I$(top_srcdir)/lib/libmd5sum \
+	-I$(top_srcdir)/lib/libupnpclient \
 	@FREETYPE_CFLAGS@
 
 if BOXTYPE_COOLSTREAM
@@ -58,6 +59,7 @@
 	$(top_builddir)/lib/libmd5sum/libtuxbox-md5sum.a \
 	$(top_builddir)/lib/libdvbsub/libdvbsub.a \
 	$(top_builddir)/lib/libtuxtxt/libtuxtxt.a \
+	$(top_builddir)/lib/libupnpclient/libtuxbox-upnpclient.a \
 	@CURL_LIBS@ \
 	@FREETYPE_LIBS@ \
 	@PNG_LIBS@ \
diff -Naur 2379/src/neutrino_menue.cpp 2380/src/neutrino_menue.cpp
--- 2379/src/neutrino_menue.cpp	2014-12-31 15:52:23.000000000 +0100
+++ 2380/src/neutrino_menue.cpp	2014-12-31 15:53:29.000000000 +0100
@@ -145,6 +145,7 @@
 #include "gui/opkg_manager.h"
 #include "gui/themes.h"
 #include "gui/webtv.h"
+#include "gui/upnpbrowser.h"
 
 
 extern CMoviePlayerGui * moviePlayerGui;	// defined in neutrino.cpp
@@ -249,6 +250,9 @@
 
 	//PictureViewer
 	MediaPlayer.addItem(new CMenuForwarderItemMenuIcon(LOCALE_MAINMENU_PICTUREVIEWER, true, NULL, new CPictureViewerGui(), NULL, CRCInput::RC_yellow, NEUTRINO_ICON_BUTTON_YELLOW, NEUTRINO_ICON_MENUITEM_PICTUREVIEWER, LOCALE_HELPTEXT_PICTUREVIEWER ));
+	
+	//UPNP Browser
+ 	MediaPlayer.addItem(new CMenuForwarderItemMenuIcon(LOCALE_UPNPBROWSER_HEAD, true, NULL, new CUpnpBrowserGui(), NULL, CRCInput::RC_blue, NEUTRINO_ICON_BUTTON_BLUE, NEUTRINO_ICON_MENUITEM_UPNPBROWSER, LOCALE_HELPTEXT_UPNPBROWSER ));
 
 	// webtv
 	mainMenu.addItem(new CMenuForwarderItemMenuIcon(LOCALE_WEBTV_HEAD, true, NULL, this, "webtv", CRCInput::RC_blue, NEUTRINO_ICON_BUTTON_BLUE, NEUTRINO_ICON_MENUITEM_WEBTV, LOCALE_HELPTEXT_SCART) );
